% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Graph.R
\docType{class}
\name{Graph}
\alias{Graph}
\title{Graph}
\description{
An R6 class to represent a graph (from discrete mathematics).
}
\details{
Encapulates and provides methods for computation and checking of undirected
graphs. Graphs are systems of vertices connected in pairs by edges.
}
\author{
Andrew Sims \email{andrew.sims@newcastle.ac.uk}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Graph$new()}}
\item \href{#method-has_vertex}{\code{Graph$has_vertex()}}
\item \href{#method-has_edge}{\code{Graph$has_edge()}}
\item \href{#method-has_element}{\code{Graph$has_element()}}
\item \href{#method-element_index}{\code{Graph$element_index()}}
\item \href{#method-order}{\code{Graph$order()}}
\item \href{#method-size}{\code{Graph$size()}}
\item \href{#method-adjacency_matrix}{\code{Graph$adjacency_matrix()}}
\item \href{#method-is_simple}{\code{Graph$is_simple()}}
\item \href{#method-is_connected}{\code{Graph$is_connected()}}
\item \href{#method-is_acyclic}{\code{Graph$is_acyclic()}}
\item \href{#method-is_tree}{\code{Graph$is_tree()}}
\item \href{#method-degree}{\code{Graph$degree()}}
\item \href{#method-neighbours}{\code{Graph$neighbours()}}
\item \href{#method-clone}{\code{Graph$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new Graph object from sets of nodes and edges.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$new(V, E)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{V}}{A list of Nodes.}

\item{\code{E}}{A list of Edges.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A Graph object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-has_vertex"></a>}}
\if{latex}{\out{\hypertarget{method-has_vertex}{}}}
\subsection{Method \code{has_vertex()}}{
Test whether a vertex an element of the graph.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$has_vertex(v)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Subject vertex.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
TRUE if v is an element of V(G).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-has_edge"></a>}}
\if{latex}{\out{\hypertarget{method-has_edge}{}}}
\subsection{Method \code{has_edge()}}{
Test whether an edge is element of the graph.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$has_edge(e)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{e}}{Subject edge.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
TRUE if e is an element of E(G).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-has_element"></a>}}
\if{latex}{\out{\hypertarget{method-has_element}{}}}
\subsection{Method \code{has_element()}}{
Test whether an edge is an element of the graph.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$has_element(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{Subject vertex or edge}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
TRUE if x is an element of V(G), the vertex set,
or x is an element of E(G), the edge set.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-element_index"></a>}}
\if{latex}{\out{\hypertarget{method-element_index}{}}}
\subsection{Method \code{element_index()}}{
Find the index of element x in the vertices or edges of the graph. The
vertices and edges are normally stored internally in the same order they 
were defined in the call to $new(), but this cannot be guaranteed. The index 
returned by this function will be same as the index of a vertex or edge 
returned by other methods, e.g. adjacancy_matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$element_index(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{The subject element (a Node or Edge).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The index of the element (integer).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-order"></a>}}
\if{latex}{\out{\hypertarget{method-order}{}}}
\subsection{Method \code{order()}}{
Return the order of the graph (number of vertices).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$order()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Order of the graph (integer).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-size"></a>}}
\if{latex}{\out{\hypertarget{method-size}{}}}
\subsection{Method \code{size()}}{
Return the size of the graph (number of edges).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$size()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Size of the graph (integer).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-adjacency_matrix"></a>}}
\if{latex}{\out{\hypertarget{method-adjacency_matrix}{}}}
\subsection{Method \code{adjacency_matrix()}}{
Compute the adjacency matrix for the graph. Each cell contains the
number of edges joining the two vertexes, with the convention of
self loops being counted twice, unless 'binary' is TRUE when cells are
either 0 (not adjacent) or 1 (adjacent).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$adjacency_matrix(boolean = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{boolean}}{If TRUE, the adjacency matrix is logical, each cell is
{FALSE,TRUE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A square numeric matrix with the number of rows and columns
equal to the order of the graph. The rows and columns are in the
same order as V. If the nodes have defined and unique labels the
dimnames of the matrix are the labels of the nodes.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-is_simple"></a>}}
\if{latex}{\out{\hypertarget{method-is_simple}{}}}
\subsection{Method \code{is_simple()}}{
A simple graph has no self loops or multi-edges.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$is_simple()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
TRUE if simple, FALSE if not.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-is_connected"></a>}}
\if{latex}{\out{\hypertarget{method-is_connected}{}}}
\subsection{Method \code{is_connected()}}{
Test whether the graph is connected. Graphs with no vertices are 
considered unconnected; graphs with 1 vertex are considered
connected. Otherwise a graph is connected if all nodes can be 
reached from an arbitrary starting point. Uses a depth first
search.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$is_connected()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
TRUE if connected, FALSE if not.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-is_acyclic"></a>}}
\if{latex}{\out{\hypertarget{method-is_acyclic}{}}}
\subsection{Method \code{is_acyclic()}}{
Checks for the presence of a cycle in the graph using a depth-first
search from each node to detect the presence of back edges. A back
edge is an edge from the current node joining a previously detected 
(visited) node, that is not the parent node of the current one.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$is_acyclic()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
TRUE if no cycles detected.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-is_tree"></a>}}
\if{latex}{\out{\hypertarget{method-is_tree}{}}}
\subsection{Method \code{is_tree()}}{
Compute whether the graph is connected and acyclic.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$is_tree()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
TRUE if the graph is a tree; FALSE if not.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-degree"></a>}}
\if{latex}{\out{\hypertarget{method-degree}{}}}
\subsection{Method \code{degree()}}{
The degree of a vertex in the graph, or number of incident edges.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$degree(v)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{The subject node.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Degree of the vertex, integer.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-neighbours"></a>}}
\if{latex}{\out{\hypertarget{method-neighbours}{}}}
\subsection{Method \code{neighbours()}}{
Find the neighbours of a node. A property of the graph, not the node.
Does not include self, even in the case of a loop to self.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$neighbours(v)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{The subject node.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of nodes which are joined to the subject.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Graph$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
