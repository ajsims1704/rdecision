% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Node.R
\docType{class}
\name{Node}
\alias{Node}
\title{Node}
\description{
An R6 class to represent a node in a decision tree
}
\details{
Base class to represent a single node in a decision tree. Objects of base
class Node are not expected to be created as model objects.
}
\author{
Andrew Sims \email{andrew.sims@newcastle.ac.uk}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Node$new()}}
\item \href{#method-label}{\code{Node$label()}}
\item \href{#method-type}{\code{Node$type()}}
\item \href{#method-clone}{\code{Node$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create new Node object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Node$new(label = "")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{label}}{An optional label for the node.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new Node object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-label"></a>}}
\if{latex}{\out{\hypertarget{method-label}{}}}
\subsection{Method \code{label()}}{
Return the label of the node.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Node$label()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Label as a character string.
#' @description
#' Return list of child nodes (DOM-style)
#' @return 
#' list of child Nodes
child_nodes = function() {
  children = list()
  for (e in private$edges) {
    children <- c(children, e$target())
  }
  return(children)
},
#' @description 
#' Return list of descendent nodes.
#' @return List of descendent nodes, including self.
descendantNodes = function() {
  nodes <- list()
  toLeaf <- function(node) {
    # push current node to path
    nodes[[length(nodes)+1]] <<- node
    # process child nodes if not leaf
    if (node$has_child_nodes()) {
      for (child in node$child_nodes()) {
        toLeaf(child)
      }
    }
  }
  toLeaf(self)
  return(nodes)
},
#' @description
#' Is this node the same as the argument? (DOM-style)
#' @param otherNode node to compare with this one
#' @return TRUE if `otherNode` is also this one
is_same_node = function(otherNode) {
  return(identical(self, otherNode)) 
},
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-type"></a>}}
\if{latex}{\out{\hypertarget{method-type}{}}}
\subsection{Method \code{type()}}{
node type
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Node$type()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Node class, as character string
#' @description
#' Trace and list all pathways ending on leaf nodes which start
#' with this node.
#' @param choice Name of choice. All pathways are returned if NA.
#' @return A list of Path objects. Each member of the list is a
#' path from this node to a leaf, limited to those associated
#' with choice, if defined.
getPathways = function(choice=NA) {
  path <- list()
  rc <- list()
  toLeaf <- function(node) {
    # push current node to path
    path[[length(path)+1]] <<- node
    # leaf reached; store the path
    if (node$has_child_nodes()) {
      # process child nodes
      for (child in node$child_nodes()) {
        toLeaf(child)
      }
    }
    else {
      p <- Path$new(path)
      if (!is.na(choice)) {
        if (p$getChoice()==choice) {
          rc[[length(rc)+1]] <<- p
        }
      }
      else {
        rc[[length(rc)+1]] <<- p
      }
    }
    # pop current node from path
    path <<- path[1:(length(path)-1)]
  }
  toLeaf(self)
  return(rc)
},
#' @description 
#' Return label of edge which links to specified child node
#' @param childNode child node to which find label of linking edge
#' @return label as character string
get_edge_label = function(childNode) {
  rv <- NA
  ie <- private$whichArrow(childNode)
  if (!is.na(ie)){
    edge <- private$edges[[ie]]
    rv <- edge$label()
  }
  return(rv)
},
#' @description 
#' Function to return a list of model variables associated with this node.
#' @return 
#' List of model variables associated with this node.
get_modvars = function() {
  return(list())
},
#' @description
#' Tabulate all model variables associated with this node.
#' @param include.descendants If TRUE, model variables associated
#' with this node and its descendants are tabulated; otherwise only
#' the ones that are associated with this node.
#' @param include.operands If TRUE, recursively add model variables which are
#' included in expressions in ExprModVars. Default is
#' FALSE.
#' @return Data frame with one row per model variable, as follows:
#' \describe{
#' \item{Label}{The label given to the variable on creation.}
#' \item{Description}{As given at initialization.}
#' \item{Units}{Units of the variable.}
#' \item{Distribution}{The uncertainty distribution or an expression.} 
#' \item{Mean}{Expected value.}
#' \item{SD}{Standard deviation.}
#' \item{Q2.5}{p=0.025 quantile.}
#' \item{Q97.5}{p=0.975 quantile.}
#' \item{Qhat}{Asterisk if the quantiles and SD were estimated by random sampling.}
#' }
tabulate_modvars = function(include.descendants=FALSE, 
                            include.operands=FALSE) {
  # create list of nodes
  if (include.descendants) {
    nodes <- self$descendantNodes()
  } 
  else {
    nodes <- list(self)
  }
  # list model variables associated with these nodes
  mvlist <- list()
  sapply(nodes, FUN=function(n) {
    mv <- n$get_modvars()
    if (length(mv) > 0) {
      mvlist <<- c(mvlist, unlist(mv))
    }
  })
  # tabulate the model variables
  DF <- do.call(
    'rbind', 
    lapply(mvlist, FUN=function(x){x$tabulate(include.operands)})
  )
  DF <- DF[!duplicated(DF),]
  # order the table
  if (nrow(DF) > 0) {
    DF <- DF[order(DF$Label),]
  }
  # return the tabulated variables
  return(DF)
},
#' @description 
#' Sample the model variables associated with the node.
#' @param expected if TRUE, use the expected value of the model variables in
#'        the node; otherwise sample from their uncertainty distributions.
#' @return Updated Node object
sample_modvars = function(expected=FALSE) {
  # get the model variables associated with this node
  mvlist <- self$get_modvars()
  # sample them
  sapply(mvlist, FUN=function(mv) {
    mv$sample(expected)
  })
  return(invisible(self))
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Node$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
