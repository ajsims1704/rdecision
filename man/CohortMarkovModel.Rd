% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CohortMarkovModel.R
\docType{class}
\name{CohortMarkovModel}
\alias{CohortMarkovModel}
\title{\verb{CohortMarkovModel}}
\value{
A square matrix of size equal to the number of states. If all
states are labelled, the dimnames take the names of the states.

A square matrix of size equal to the number of states. If all
states are labelled, the dimnames take the names of the states.

A numeric vector of populations, named with state names.

Elapsed time as an R \code{difftime} object.

A data frame with the following columns:
\describe{
\item{Name}{State name}
\item{Cost}{Annual cost of occupying the state}
\item{Utility}{Incremental utility associated with being in the state.}
}

Calculated values, one row per state, as a data frame with the
following columns:
\describe{
\item{\code{State}}{Name of the state.}
\item{\code{Cycle}}{The cycle number.}
\item{\code{Time}}{Clock time, years.}
\item{\code{Population}}{Population of the state at the end of 
the cycle, or at mid-cycle if half-cycle correction is applied.}
\item{\code{OccCost}}{Cost of the population occupying the state for 
the cycle. Discount is applied, if the options are set. The costs are
normalized by the model population. The cycle costs are derived from the
annual occupancy costs of the \code{MarkovState}s. Applied to the end
population, i.e. unaffacted by half cycle correction, as per 
Briggs \emph{et al}.}
\item{code{EntryCost}}{Cost of the transitions \emph{into} the state
during the cycle. Discounting is applied, if the option is set. 
The result is normalized by the model population. The cycle costs
are derived from \code{MarkovTransition} costs.}
\item{\code{Cost}}{Total cost, normalized by model population.}
\item{QALY}{Quality adjusted life years gained by occupancy of the states
during the cycle. Half cycle correction and discounting are applied,
if these options are set. Normalized by the model population.}
}

Data frame with cycle results.
following columns:
\describe{
\item{\code{Cycle}}{The cycle number.}
\item{\code{Time}}{Elapsed time at end of cycle, years}
\item{\code{<name>}}{Population of state \code{<name} at the end of
the cycle.}
\item{\code{Cost}}{Cost associated with occupancy and transitions between
states during the cycle.}
\item{\code{QALY}}{Quality adjusted life years associated with occupancy
of the states in the cycle.}
}
}
\description{
An R6 class for a Markov model with cohort simulation.
}
\details{
A class to represent a Markov model, using cohort simulation. In 
graph theory terms, a Markov model is a directed multidigraph permitting 
loops (a loop multidigraph), optionally labelled, or a \dfn{quiver}. It is a
multidigraph because there are potentially two edges between each pair of
nodes {A,B} representing the transition probabilities from A to B and 
\emph{vice versa}. It is a directed graph because the transition
rates refer to transitions in one direction. Each edge can be optionally
labelled. It permits loops (edges whose source and target are the same node)
to represent patients that remain in the same state between cycles.
}
\section{Probabilities and rates}{

To calculate per-cycle probabilities from rates, Briggs (2002) and
Sonnenberg & Beck (1993) use the expression \eqn{p = 1-\exp(-rt)}, where 
\eqn{r} is an instantaneous rate
and \eqn{t} is a time interval of interest. This is derived by assuming that 
if there is a population of \eqn{N} patients the rate of events is
proportional to the number of patients, i.e. that events occur independently:
\eqn{\frac{dN}{dt} \propto N}. The number of patients, \eqn{N(t)} who have
not experienced an event at time \eqn{t} is therefore given by the solution
to this differential equation, i.e. \eqn{N(t) = N e^{-r t}}, where \eqn{r}
is the rate, or the reciprocal of the time constant. The expected number of 
events \eqn{\hat{K}} which occur in interval \eqn{t} from a starting 
population of \eqn{N} is \eqn{\hat{K} = N - N e^{-r t}}, or 
\eqn{\hat{K} = Np}, where \eqn{p = 1-\exp(-r t)}, the probability with 
which events arise during interval \eqn{t}. If instead a per-interval 
probability is known, the rate is derived from the inverse relationship 
\eqn{r = -\ln(1-p)/t}.
}

\references{
{
  Briggs A, Claxton K, Sculpher M. Decision modelling for health economic 
  evaluation. Oxford, UK: Oxford University Press; 2006.
  
  Sonnenberg FA, Beck JR. Markov models in medical decision making: a
  practical guide. \emph{Med Decis Making}, 1993:\strong{13}:322. 
}
}
\author{
Andrew J. Sims \email{andrew.sims@newcastle.ac.uk}
}
\section{Super classes}{
\code{\link[rdecision:Graph]{rdecision::Graph}} -> \code{\link[rdecision:Digraph]{rdecision::Digraph}} -> \code{CohortMarkovModel}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{CohortMarkovModel$new()}}
\item \href{#method-transition_probability}{\code{CohortMarkovModel$transition_probability()}}
\item \href{#method-transition_cost}{\code{CohortMarkovModel$transition_cost()}}
\item \href{#method-get_statenames}{\code{CohortMarkovModel$get_statenames()}}
\item \href{#method-reset}{\code{CohortMarkovModel$reset()}}
\item \href{#method-get_populations}{\code{CohortMarkovModel$get_populations()}}
\item \href{#method-get_elapsed}{\code{CohortMarkovModel$get_elapsed()}}
\item \href{#method-tabulate_states}{\code{CohortMarkovModel$tabulate_states()}}
\item \href{#method-cycle}{\code{CohortMarkovModel$cycle()}}
\item \href{#method-cycles}{\code{CohortMarkovModel$cycles()}}
\item \href{#method-modvars}{\code{CohortMarkovModel$modvars()}}
\item \href{#method-modvar_table}{\code{CohortMarkovModel$modvar_table()}}
\item \href{#method-clone}{\code{CohortMarkovModel$clone()}}
}
}
\if{html}{
\out{<details ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="degree">}\href{../../rdecision/html/Graph.html#method-degree}{\code{rdecision::Graph$degree()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_index">}\href{../../rdecision/html/Graph.html#method-edge_index}{\code{rdecision::Graph$edge_index()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="graph_adjacency_matrix">}\href{../../rdecision/html/Graph.html#method-graph_adjacency_matrix}{\code{rdecision::Graph$graph_adjacency_matrix()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_edge">}\href{../../rdecision/html/Graph.html#method-has_edge}{\code{rdecision::Graph$has_edge()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_vertex">}\href{../../rdecision/html/Graph.html#method-has_vertex}{\code{rdecision::Graph$has_vertex()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="is_simple">}\href{../../rdecision/html/Graph.html#method-is_simple}{\code{rdecision::Graph$is_simple()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="neighbours">}\href{../../rdecision/html/Graph.html#method-neighbours}{\code{rdecision::Graph$neighbours()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="order">}\href{../../rdecision/html/Graph.html#method-order}{\code{rdecision::Graph$order()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="size">}\href{../../rdecision/html/Graph.html#method-size}{\code{rdecision::Graph$size()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_index">}\href{../../rdecision/html/Graph.html#method-vertex_index}{\code{rdecision::Graph$vertex_index()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="as_DOT">}\href{../../rdecision/html/Digraph.html#method-as_DOT}{\code{rdecision::Digraph$as_DOT()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="digraph_adjacency_matrix">}\href{../../rdecision/html/Digraph.html#method-digraph_adjacency_matrix}{\code{rdecision::Digraph$digraph_adjacency_matrix()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="digraph_incidence_matrix">}\href{../../rdecision/html/Digraph.html#method-digraph_incidence_matrix}{\code{rdecision::Digraph$digraph_incidence_matrix()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="direct_predecessors">}\href{../../rdecision/html/Digraph.html#method-direct_predecessors}{\code{rdecision::Digraph$direct_predecessors()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="direct_successors">}\href{../../rdecision/html/Digraph.html#method-direct_successors}{\code{rdecision::Digraph$direct_successors()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_acyclic">}\href{../../rdecision/html/Digraph.html#method-is_acyclic}{\code{rdecision::Digraph$is_acyclic()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_arborescence">}\href{../../rdecision/html/Digraph.html#method-is_arborescence}{\code{rdecision::Digraph$is_arborescence()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_connected">}\href{../../rdecision/html/Digraph.html#method-is_connected}{\code{rdecision::Digraph$is_connected()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_polytree">}\href{../../rdecision/html/Digraph.html#method-is_polytree}{\code{rdecision::Digraph$is_polytree()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_tree">}\href{../../rdecision/html/Digraph.html#method-is_tree}{\code{rdecision::Digraph$is_tree()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_weakly_connected">}\href{../../rdecision/html/Digraph.html#method-is_weakly_connected}{\code{rdecision::Digraph$is_weakly_connected()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="paths">}\href{../../rdecision/html/Digraph.html#method-paths}{\code{rdecision::Digraph$paths()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="topological_sort">}\href{../../rdecision/html/Digraph.html#method-topological_sort}{\code{rdecision::Digraph$topological_sort()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="walk">}\href{../../rdecision/html/Digraph.html#method-walk}{\code{rdecision::Digraph$walk()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Creates a Markov model for cohort simulation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$new(V, E, discount.cost = 0, discount.utility = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{V}}{A list of nodes (\code{MarkovState}s).}

\item{\code{E}}{A list of edges (\code{MarkovTransition}s).}

\item{\code{discount.cost}}{Annual discount rate for future costs.}

\item{\code{discount.utility}}{Annual discount rate for future incremental
utility.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A Markov model must meet the following conditions:
\enumerate{
  \item It must have at least one node and at least one edge.
  \item All nodes must be of class \code{MarkovState};
  \item All edges must be of class \code{MarkovTransition};
  \item The nodes and edges must form a digraph whose underlying
  graph is connected;
  \item Each state must have at least one outgoing transition and 
  have exactly one outgoing edge whose hazard rate is NULL. This is to
  ensure that the multinomial distribution of the probability of leaving
  each node is not over or under-constrained. Rates can be changed
  between cycles, and this constraint is checked at the point of cycling,
  not at the point of model creation.
  \item No two edges may share the same source and target nodes (i.e. 
  the digraph may not have multiple edges). This is to ensure that there
  are no more transitions than cells in the transition matrix.
}
}

\subsection{Returns}{
A \code{CohortMarkovModel} object. The population of the first
state is set to 1000.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-transition_probability"></a>}}
\if{latex}{\out{\hypertarget{method-transition_probability}{}}}
\subsection{Method \code{transition_probability()}}{
Return the per-cycle transition matrix for the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$transition_probability(tcycle)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tcycle}}{Cycle length, expressed as an R \code{difftime} object.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Checks that each state has at least one outgoing transition and
that exactly one outgoing transition rate whose rate is NULL.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-transition_cost"></a>}}
\if{latex}{\out{\hypertarget{method-transition_cost}{}}}
\subsection{Method \code{transition_cost()}}{
Return the per-cycle transition costs for the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$transition_cost()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_statenames"></a>}}
\if{latex}{\out{\hypertarget{method-get_statenames}{}}}
\subsection{Method \code{get_statenames()}}{
Returns a character list of state names.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$get_statenames()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
List of the names of each state.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-reset"></a>}}
\if{latex}{\out{\hypertarget{method-reset}{}}}
\subsection{Method \code{reset()}}{
Resets the model counters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$reset(
  populations = NULL,
  icycle = as.integer(0),
  elapsed = as.difftime(0, units = "days")
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{populations}}{A named vector of populations for
the start of the state. The names should be the state names. 
Due to the R implementation of matrix algebra, \code{populations} 
must be a numeric type and is not restricted to being an integer. If 
NULL, the population of the first state is set to 1000 and the others
to zero.}

\item{\code{icycle}}{Cycle number at which to start/restart.}

\item{\code{elapsed}}{Elapsed time since the index (reference) time used for
discounting as an R \code{difftime} object.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Resets the state populations, next cycle number and elapsed time
of the model. By default the model is returned to its ground state (1000
people in the first state and zero in the others; next cycle is labelled
zero; elapsed time (years) is zero). Any or all of these can be set via 
this function. \code{icycle} is simply an integer counter label for each 
cycle, \code{elapsed} sets the elapsed time in years from the index time
from which discounting is assumed to apply.
}

\subsection{Returns}{
Updated \code{CohortMarkovModel} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_populations"></a>}}
\if{latex}{\out{\hypertarget{method-get_populations}{}}}
\subsection{Method \code{get_populations()}}{
Gets the occupancy of each state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$get_populations()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_elapsed"></a>}}
\if{latex}{\out{\hypertarget{method-get_elapsed}{}}}
\subsection{Method \code{get_elapsed()}}{
Gets the current elapsed time.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$get_elapsed()}\if{html}{\out{</div>}}
}

\subsection{Details}{
The elapsed time is defined as the difference between the 
current time in the model and an index time used as the reference
time for applying discounting. By default the elapsed time starts at
zero. It can be set directly by calling \code{reset}. It is incremented
after each call to \code{cycle} by the cycle duration to the time at the
end of the cycle (even if half cycle correction is used). Thus, via the
\code{reset} and \code{cycle} methods, the time of each cycle relative 
to the discounting index and its duration can be controlled arbitrarily.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-tabulate_states"></a>}}
\if{latex}{\out{\hypertarget{method-tabulate_states}{}}}
\subsection{Method \code{tabulate_states()}}{
Tabulation of states
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$tabulate_states()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Creates a data frame summary of each state in the model.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-cycle"></a>}}
\if{latex}{\out{\hypertarget{method-cycle}{}}}
\subsection{Method \code{cycle()}}{
Applies one cycle of the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$cycle(
  tcycle = as.difftime(365.25, units = "days"),
  hcc.pop = TRUE,
  hcc.cost = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tcycle}}{Cycle length, expressed as an R \code{difftime} object; 
default 1 year.}

\item{\code{hcc.pop}}{Boolean; whether to apply half cycle correction to the
population and QALY. If TRUE, the correction is only applied to the 
outputs of 
functions \code{cycle} and \code{cycles}; the state population passed to
the next cycle is the end cycle population, obtainable 
with \code{get_populations}.}

\item{\code{hcc.cost}}{Boolean; whether to apply half cycle correction to the
costs. If true, the occupancy costs are computed using the population
at half cycle; if false they are applied at the end of the cycle. 
Applicable only if hcc.pop is TRUE.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-cycles"></a>}}
\if{latex}{\out{\hypertarget{method-cycles}{}}}
\subsection{Method \code{cycles()}}{
Applies multiple cycles of the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$cycles(
  ncycles = 2,
  tcycle = as.difftime(365.25, units = "days"),
  hcc.pop = TRUE,
  hcc.cost = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ncycles}}{Number of cycles to run; default is 2.}

\item{\code{tcycle}}{Cycle length, expressed as an R \code{difftime} object; 
default 1 year.}

\item{\code{hcc.pop}}{Boolean; whether to apply half cycle correction to the
population and QALY. If TRUE, the correction is only applied to the 
outputs of functions \code{cycle} and \code{cycles}; the state 
population passed to
the next cycle is the end cycle population, obtainable 
with \code{get_populations}.}

\item{\code{hcc.cost}}{Boolean; whether to apply half cycle correction to the
costs. If true, the occupancy costs are computed using the population
at half cycle; if false they are applied at the end of the cycle.
Applicable only if hcc.pop is TRUE.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The starting populations are redistributed through the
transition probabilities and the state occupancy costs are
calculated, using function \code{cycle}. The end populations are
then fed back into the model for a further cycle and the
process is repeated. For each cycle, the state populations and
the aggregated occupancy costs are saved in one row of the
returned data frame, with the cycle number. If the cycle count
for the model is zero when called, the first cycle reported
will be cycle zero, i.e. the distribution of patients to starting
states.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-modvars"></a>}}
\if{latex}{\out{\hypertarget{method-modvars}{}}}
\subsection{Method \code{modvars()}}{
Find all the model variables in the Markov model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$modvars()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Returns variables of type \code{ModVar} that have been 
specified as values associated with transition rates and costs and
the state occupancy costs and utilities.
}

\subsection{Returns}{
A list of \code{ModVar}s.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-modvar_table"></a>}}
\if{latex}{\out{\hypertarget{method-modvar_table}{}}}
\subsection{Method \code{modvar_table()}}{
Tabulate the model variables in the Markov model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$modvar_table(expressions = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expressions}}{A logical that defines whether expression model
variables should be included in the tabulation.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Data frame with one row per model variable, as follows:
\describe{
\item{\code{Description}}{As given at initialization.}
\item{\code{Units}}{Units of the variable.}
\item{\code{Distribution}}{Either the uncertainty distribution, if
it is a regular model variable, or the expression used to create it,
if it is an \code{ExprModVar}.}
\item{\code{Mean}}{Mean; calculated from means of operands if
an expression.}
\item{\code{E}}{Expectation; estimated from random sample if expression, 
mean otherwise.}
\item{\code{SD}}{Standard deviation; estimated from random sample if
expression, exact value otherwise.}
\item{\code{Q2.5}}{p=0.025 quantile; estimated from random sample if
expression, exact value otherwise.}
\item{\code{Q97.5}}{p=0.975 quantile; estimated from random sample if
expression, exact value otherwise.}
\item{\code{Est}}{TRUE if the quantiles and SD have been estimated by 
random sampling.}
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CohortMarkovModel$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
