---
title: "Elementary Markov Model (Chancellor 1997)"
subtitle: "Monotherapy versus combination therapy for HIV"
author: "Andrew J. Sims"
date: "May 2021"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Elementary Markov Model (Chancellor 1997)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: "../inst/REFERENCES.bib"
csl: "../inst/national-institute-of-health-research.csl"
---
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=F}
library(rdecision)
```

# Introduction
This vignette is an example of an elementary cohort Markov model using 
the `rdecision` package. It is based on the example given by 
Briggs *et al* [-@briggs2006] (Exercise 2.5) which itself is based on a Markov
model described by Chancellor *et al* [@chancellor1997]. The model compares 
a combination therapy of Lamivudine/Zidovudine versus Zidovudine monotherapy 
in people with HIV infection.

# Creating the model
The variables used in the model are all numerical constants, and are defined
as follows. The original model was based on annual transition probabilities;
these are converted to instantaneous hazard rates in units of events/year.
```{r model-variables, echo=TRUE}
# transition rates calculated from annual transition probabilities
trAB <- -log(1-0.202)/1 
trAC <- -log(1-0.067)/1
trAD <- -log(1-0.010)/1
trBC <- -log(1-0.407)/1
trBD <- -log(1-0.012)/1
trCD <- -log(1-0.250)/1
# Costs
dmca <- 1701 # direct medical costs associated with state A
dmcb <- 1774 # direct medical costs associated with state B
dmcc <- 6948 # direct medical costs associated with state C
ccca <- 1055 # Community care costs associated with state A
cccb <- 1278 # Community care costs associated with state B
cccc <- 2059 # Community care costs associated with state C
# Drug costs
cAZT <- 2278 # zidovudine drug cost
cLam <- 2086 # lamivudine drug cost
# Other parameters
RR <- 0.509 # treatment effect
cDR <- 6 # annual discount rate, costs (%)
oDR <- 6 # annual discount rate, benefits (%)
```

The monotherapy model is constructed by forming a graph, with each state as a 
node and each transition as an edge. Nodes (of class `MarkovState`) and edges
(class `MarkovTransition`) have various properties whose values reflect the
variables of the model (costs, rates etc.). The rate for one of the outgoing
transitions from each non-absorbing state is set to NULL to allow the sum
of probabilities leaving each state, per cycle, to be adjusted to 1. The usual
case, as here, is to set the self-loop rates to NULL (i.e. the probability of
remaining in a state is given by one minus the probability of leaving 
the state).
```{r mono-model, echo=T}
# create Markov states for monotherapy (zidovudine only)
s.mono.A <- MarkovState$new("A", cost=dmca+ccca+cAZT)
s.mono.B <- MarkovState$new("B", cost=dmcb+cccb+cAZT)
s.mono.C <- MarkovState$new("C", cost=dmcc+cccc+cAZT)
s.mono.D <- MarkovState$new("D", cost=0)
# create transitions
tAA <- MarkovTransition$new(s.mono.A, s.mono.A, r=NULL)
tAB <- MarkovTransition$new(s.mono.A, s.mono.B, r=trAB)
tAC <- MarkovTransition$new(s.mono.A, s.mono.C, r=trAC)
tAD <- MarkovTransition$new(s.mono.A, s.mono.D, r=trAD)
tBB <- MarkovTransition$new(s.mono.B, s.mono.B, r=NULL)
tBC <- MarkovTransition$new(s.mono.B, s.mono.C, r=trBC)
tBD <- MarkovTransition$new(s.mono.B, s.mono.D, r=trBD)
tCC <- MarkovTransition$new(s.mono.C, s.mono.C, r=NULL)
tCD <- MarkovTransition$new(s.mono.C, s.mono.D, r=trCD)
tDD <- MarkovTransition$new(s.mono.D, s.mono.D, r=NULL)
# construct the model
m.mono <- CohortMarkovModel$new(
  V = list(s.mono.A, s.mono.B, s.mono.C, s.mono.D),
  E = list(tAA, tAB, tAC, tAD, tBB, tBC, tBD, tCC, tCD, tDD),
  discount.cost = cDR/100,
  discount.utility = oDR/100
)
```

# Checking the model

## Diagram
A representation of the model in DOT format ([Graphviz](https://graphviz.org))
can be created using the `as_DOT` function of `CohortMarkovModel`. The function
returns a character vector which can be saved in a file (`.gv` extension) for
visualization with the `dot` tool of Graphviz, or plotted directly in R via
the `DiagrammeR` package. The Markov model for monotherapy is as follows:

```{r draw, echo=FALSE}
DOT <- m.mono$as_DOT()
#writeLines(DOT, con="mono.gv")
```
![mono graph]("mono.png")

## Summary of model states
```{r echo=T}
#model.states <- m.mono$stateSummary()
```

```{r echo=F}
#knitr::kable(model.states)
#rm(model.states)
```

## Summary of annual transition probabilities
```{r echo=T}
#transition.matrix <- m.mono$transitionSummary()
```

```{r echo=F}
#knitr::kable(transition.matrix)
#rm(transition.matrix)
```


# Running the model

## Single cycle
Model function `cycle` applies one cycle of a Markov model to a defined 
starting population in each state. It returns a table with one row per state, 
and each row containing several columns, including the population at the end of
the state, and the cost of occupancy of states, normalized by the number of 
patients in the cohort, with discounting applied. For example, the first cycle 
of the model is as follows:

```{r echo=T}
# create starting populations
#populations <- c('A'=1000, 'B'=0, 'C'=0, 'D'=0)
#m.mono$setPopulations(populations)
# run the model
#DF <- m.mono$cycle()
```
which returns the following result:
```{r echo=F}
#knitr::kable(DF)
#rm(DF)
```

## Multiple cycles
Multiple cycles are run by feeding the state populations at the end of
one cycle into the next. Function `cycles` returns a data frame with one 
row per cycle, and each row containing the state populations and the
aggregated cost of
occupancy for all states, with discounting applied. If costs per
state, per cycle, are needed, use the lower level function `cycle` to extract
state values. Below, this is done for
the first 20 cycles of the model. In addition, the proportion
of patients alive at each cycle is added to the table.  
```{r echo=T}
# create starting populations
#N <- 1000
#populations <- c('A'=N, 'B'=0, 'C'=0, 'D'=0)
#m.mono$setPopulations(populations)
# run 20 cycles
#DF.mono <- m.mono$cycles(nCycles=20+1)
# calculate the proportion alive at each cycle
#DF.mono$Alive <- (DF.mono$A + DF.mono$B + DF.mono$C)/N
```

This yields the following summary table for monotherapy:
```{r echo=F}
#knitr::kable(DF.mono)
```


# Model results

## Expected survival
The estimated life years is given by summing the proportions of
patients left alive at each cycle [@briggs2006, Exercise 2.5]. This is
proved as follows. If patients are
assumed to die at the start of the cycle, then the expected life years
is equal to the probability of death in one cycle multiplied by the
survival time. 
If $p_i$ is the proportion of patients alive at the start of cycle $i$, 
then the expected life years is given by
$$
\begin{aligned}
E[LY] &= (p_0 - p_1) \times 0 + (p_2 - p_1) \times 1 + \quad ... \quad + (p_{n-1}-p_n)\times (n-1)\\
&= \sum_1^N (p_{i-1} -p_i)\times (i-1)\\
&= \sum_1^N (ip_{i-1}-ip_i -p_{i-1} + p_i)\\
&= \sum_1^N (i-1)p_{i-1} - \sum_1^N i p_i + \sum_1^N p_i\\
&= -Np_n + \sum_1^N p_i\\
\end{aligned}
$$
If $p_N = 0$ (*i.e.* all patients have died by cycle $N$), then $E[LY] = \sum_1^N p_i$. 

## Combination therapy
For combination therapy, the model is constructed as follows:
```{r echo=T}
# create Markov states for combination therapy (zidovudine and lamivudine)
#state.comb.A <- MarkovState$new("A", dmca+ccca+cAZT+cLam)
#state.comb.B <- MarkovState$new("B", dmcb+cccb+cAZT+cLam)
#state.comb.C <- MarkovState$new("C", dmcc+cccc+cAZT+cLam)
#state.comb.D <- MarkovState$new("D", 0)
## transition matrix for combination therapy
#I.comb <- matrix(
#  data = c(0.858, 0.103, 0.034, 0.005,
#           0.000, 0.787, 0.207, 0.006,
#           0.000, 0.000, 0.873, 0.127,
#           0.000, 0.000, 0.000, 1.000),
#  nrow = 4,
#  ncol = 4, 
#  byrow = T,
#  dimnames = list(c('A', 'B', 'C', 'D'), c('A', 'B', 'C', 'D'))
#)
## construct the model
#m.comb <- MarkovModel$new(
#  states = list(state.comb.A, state.comb.B, state.comb.C, state.comb.D),
#  Ip = I.comb,
#  discount = 6.0
#)
```

In this model, lamivudine is given for the first 2 years, with 
the treatment effect assumed to persist for the same period. The
state populations and cycle numbers are retained by the model between 
calls to `cycle` or `cycles` making it easy to change probabilities or
costs during a simulation. Helper functions `setAnnualCost`, `setEntryCost`
(for a `MarkovState` object) and `setTransitions` (for a `MarkovModel`
object) are provided for that purpose.
```{r echo=T}
# run combination therapy model for 2 years
#N <- 1000
#populations <- c('A'=N, 'B'=0, 'C'=0, 'D'=0)
#m.comb$setPopulations(populations)
#DF.comb <- m.comb$cycles(nCycles=2+1)
## revise costs and transitions, and run model for next 18 years
#state.comb.A$setAnnualCost(1701+1055+2278)
#state.comb.B$setAnnualCost(1774+1278+2278)
#state.comb.C$setAnnualCost(6948+2059+2278)
#m.comb$setTransitions(I.mono)
#DF.comb <- rbind(DF.comb, m.comb$cycles(nCycles=18))
## calculate the proportion alive at end of each cycle
#DF.comb$Alive <- (DF.comb$A + DF.comb$B + DF.comb$C)/N
```

The cycle history for combination therapy is as follows:
```{r echo=F}
#knitr::kable(DF.comb)
```

## Comparison of treatments
```{r echo=F}
#el.mono <- sum(DF.mono$Alive)
#el.comb <- sum(DF.comb$Alive)
#cost.mono <- sum(DF.mono$Cost)
#cost.comb <- sum(DF.comb$Cost)
#icer <- (cost.comb-cost.mono)/(el.comb-el.mono)
```
The ICER is calculated by running both models and calculating the incremental
cost per life year gained. 

```{r echo=FALSE}
#Over the 20 year time horizon, the expected life years for monotherapy was
#`r round(el.mono,3)` years at a total cost per patient of 
#`r format(cost.mono,digits=2,scientific=F,big.mark=',')` GBP. The expected life years
#with combination therapy
#was `r round(el.comb,3)` at a total cost per patient of 
#`r format(cost.comb,digits=2,scientific=F,big.mark=',')` GBP. 
#The incremental change in life years was `r round(el.comb-el.mono,3)` years
#at an incremental cost of 
#`r format(cost.comb-cost.mono,digits=2,scientific=F,big.mark=',')` GBP,
#giving an ICER of `r round(icer,2)` GBP.
```


# References
